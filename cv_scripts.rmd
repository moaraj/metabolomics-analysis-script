---
title: "CV_analysis"
author: "Moaraj_Hasan"
date: "29 Januar 2017"
output:
  html_document: default
  pdf_document: default
---

Generate a Visual Basic Script that can convert xls and xlsx files into csv in local directory 
xls files are notoriously difficult to handle in R, csv conversion allows low memory

```{r setup,}
#setwd("D:/Dropbox/Aging BXD Study/D _ Metabolomics/D _ Protocol Optimization/CV Calcs")

excel_script <- 
    'if WScript.Arguments.Count < 2 Then
    WScript.Echo "Please specify the source and the destination files. Usage: ExcelToCsv <xls/xlsx source file> <csv destination file>"
Wscript.Quit
End If

csv_format = 6

Set objFSO = CreateObject("Scripting.FileSystemObject")

src_file = objFSO.GetAbsolutePathName(Wscript.Arguments.Item(0))
dest_file = objFSO.GetAbsolutePathName(WScript.Arguments.Item(1))

Dim oExcel
Set oExcel = CreateObject("Excel.Application")

Dim oBook
Set oBook = oExcel.Workbooks.Open(src_file)

oBook.SaveAs dest_file, csv_format

oBook.Close False
oExcel.Quit'

script_file_name = "ExcelToCsv.vbs"
write(excel_script,file = script_file_name)
# The script above allows command line conversion of xlxs file to csv conversiton in command line
#The script syntax: 
#XlsToCsv.vbs [sourcexlsFile].xls [destinationcsvfile].csv

```

The following script takes thes first xls file and performs the conversion using the script
```{r, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
library(tools)
abs_path <- file_path_as_absolute(dir(pattern = "\\.xls")[1])
cmd_command <- paste(c(script_file_name, abs_path, 
                       paste(strsplit(abs_path,".xls"),".csv", sep = "")), 
                     sep = " ", collapse = " ")

system(command = cmd_command)
```

Install all the required dependcies
```{r, message=FALSE, warning=FALSE, eval=FALSE}
install.packages("dplyr")
install.packages("ggplot2")
install.packages("plyr")
install.packages("matrixStats")
install.packages("readr")
install.packages("tidyr")
install.packages("splitstackshape")
```

Initalize data handling dependencies
```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(plyr)
library(readr)
library(tidyr)
library(splitstackshape)
library(matrixStats)
library(tibble)
library(heplots)
```

Import Annotated Files, Tranposed, all commas, spaces and semi colons removed in notepad++. 
INSERT "index, extraction, mouse, diet, sex," to first row

```{r}
Data_Curated_Annotations_transpose <- read_csv("Data_Curated_Annotations_transpose.csv", 
    col_types = cols( `71.0137` = col_integer(), extraction = col_character(), 
        index = col_integer()))

metab_data <- Data_Curated_Annotations_transpose %>% dplyr::mutate_each_(., funs = funs(as.factor), vars = c("extraction", "diet", "sex", "mouse")) 


```

Get the Mean reading of each metabolite and visualize in a box plot
```{r, message=FALSE, warning=FALSE}

sample_sd <-lapply(metab_data[6:length(names(metab_data))], function(x) sd(x))
sample_mean <-lapply(metab_data[6:length(names(metab_data))], function(x) mean(x))

p <- ggplot(metab_data, aes(factor(extraction), mouse ))
p + geom_violin() + geom_boxplot(width=.1)

extraction <- metab_data[metab_data$extraction %in% "H1",]
```

Add indexes for replicaites using the mod function on the sample index
```{r}
#mod<-function(x,m){
#    t1<-floor(x/m)
#    return(x-t1*m)
#}

#index_vector        <- c(1:nrow(metab_data))
#replicate_index     <- mod(metab_data$index,2)
#replicate_index     <- as.data.frame(as.character(rev((replicate_index + 1))))
#index_vector        <- cbind(index_vector, replicate_index)
#names(index_vector) <- c("index", "replicate")

metab_data <- merge(metab_data 
                    %>% mutate(replicate  = paste("rep_", rep(c(1,2), times = dim(metab_data)[1]/2), sep = "")) 
                    %>% select(index, replicate), metab_data, by = "index")

#zou need to have unqiue values in the bz mere
#can be done by selecting multiple columns
```


ANOVA fit
```{r, fig.height=4, fig.width=4}

Data_Annotations    <- read.csv(file = "Data_Curated_Annotations.csv",stringsAsFactors = FALSE)
primary_names       <- Data_Annotations$Primary.Name
meta_data           <- c("index","replicate","extraction","mouse","diet","sex")
primary_meta_names  <- c(meta_data, primary_names)

#names(metab_data)   <- primary_meta_names
#duplicated_colnames <- which(duplicated(primary_meta_names,fromLast = FALSE))
#metab_data<-lapply(duplicated_colnames, function(x) metab_data[-x])


duplicated_cols <- which(duplicated(primary_meta_names))
filtered_metab_data <- metab_data %>% select(-duplicated_cols)
filtered_primary_meta_names <- primary_meta_names[-duplicated_cols]
final_metab_data <- filtered_metab_data %>% setnames(filtered_primary_meta_names)

#Set up variables for the aov analysis
metab <- final_metab_data

counts <- as.matrix(log(metab[7:20]))
#extraction  <- metab$extraction
#mouse   <- metab$mouse
#diet    <- metab$diet
#sex     <- metab$sex
#replicate <- metab$replicate
  
fit <- aov(formula = as.formula("counts ~ sex + diet + extraction + replicate"), data = metab)
fit2 <- glm(formula = as.formula("counts ~ sex + diet + extraction + replicate"), data = metab)

metab.mod <- lm(as.matrix(metab[7:10]) ~ sex + diet, data=metab)
Anova(metab.mod, test.statistic="Roy")


summary(fit)
summary(fit2)

plot(fit,which = 1:2)
plot(fit2, which = 1:6)

p <- ggplot(metab_data, aes(x = diet, y = metab_data$Pyruvaldehyde)) +
  geom_boxplot(fill = "grey80", colour = "blue") +
  scale_x_discrete() + xlab("Treatment Group") +
  ylab("Log Metabolite Intensities")

```

Generate Table to compare Chow and High Fat Diet metabolites
Script for extracting just cohort subsets
```{r}
#Exctraction Cohorts
Hot_data  <- filter(final_metab_data,extraction == "Hot") %>% filter(sex == "F")
H1_data   <- filter(final_metab_data,extraction == "H1") %>% filter(sex == "F")
H24_data  <- filter(final_metab_data,extraction == "H24") %>% filter(sex == "F")
NH24_data <- filter(final_metab_data,extraction == "NH24") %>% filter(sex == "F")

#Diet Cohorts
HF_data <- filter(final_metab_data, diet == "HF") %>% filter(sex == "F")
CD_data <- filter(final_metab_data, diet == "CD") %>% filter(sex == "F")

#Replicate Cohorts
rep_1_data <- filter(final_metab_data, replicate == "rep_1") %>% filter(sex == "F")
rep_2_data <- filter(final_metab_data, replicate == "rep_2") %>% filter(sex == "F")


```

Violin Plots for the Metabolite Cohorts
```{r}
HF_mean <-as.numeric(lapply(HF_data[7:length(names(HF_data))], function(x) mean(x)))
CD_mean <-as.numeric(lapply(CD_data[7:length(names(CD_data))], function(x) mean(x)))

HF_sd <-as.numeric(lapply(HF_data[7:length(names(HF_data))], function(x) sd(x)))
CD_sd <-as.numeric(lapply(HF_data[7:length(names(HF_data))], function(x) sd(x)))

HF_CV <-HF_sd/HF_mean 
CD_CV <-CD_sd/CD_mean

rep_1_data <-as.numeric(lapply(rep_1_data[7:length(names(rep_1_data))], function(x) sd(x)/mean(x)))
rep_2_data <-as.numeric(lapply(rep_2_data[7:length(names(rep_2_data))], function(x) sd(x)/mean(x)))

Diet_data <- data.frame(HF_CV,CD_CV)
names(Diet_data) <- c("HF_cv","CD_cv")
Diet_data$Index <- 1:nrow(Diet_data)

metab_data <- melt(Diet_data, id="Index")

q <- ggplot(metab_data, aes(factor(variable), log(value)))
q + geom_violin() + geom_boxplot(width=.1) 
# violin plot with median points

vioplot2(Hot_data)
```


Load libraries and generate the data
```{r}
library('broom')
library('dplyr')
library('ggplot2')
library('tidyr')

set.seed(20160229)

my_data = data.frame(
    # dependent variable
    dv=c(rnorm(1000), rnorm(1000, 0.5), rnorm(1000, 1), rnorm(1000, 1.5)),

    # x-axis grouping variable
    x_group=c(rep('a', 2000), rep('b', 2000)),

    # variable to use to split the violins
    m=c(rep('i', 1000), rep('j', 2000), rep('i', 1000))
)
```

Get the group levels for the split variable

```{r}
splits = unique(my_data[['m']])
```

Calculate and scale group densities
I'm rescaling the density curves so that they all have the same peak height and don't overlap. Edit the mutate() line if you want to have the density polygons be different sizes (e.g., scaled so that they show the relative amount of data in each group).
```{r}
pdat = my_data %>%
    group_by(x_group, m) %>%
    do(tidy(density(.[['dv']]))) %>%
    rename(loc = x, dens = y) %>%
    mutate(dens = 0.5 * dens / max(dens)) %>%
    ungroup()
```


Calculate summary statistics in a separate dataframe

If you need more summary statistics, add new variables to the summarise() call here, and add the additional variable names to the gather() call.
```{r}
sums = my_data %>%
    group_by(x_group, m) %>%
    summarise(lquart_loc = quantile(dv)[[2]],
              uquart_loc = quantile(dv)[[4]]) %>%
    ungroup() %>%
    gather(segment, loc_sum, lquart_loc, uquart_loc)
```

Calculate the corresponding points on each group's density curve

To do this, I'm taking the scaled density curves stored in pdat, then feeding them into the approx() function, plus the y-axis locations of the summary statistics (loc_sum), to get the corresponding x-axis values for the summary statistics.
```{r}
sums = left_join(pdat, sums, by=c('x_group', 'm')) %>%
    group_by(x_group, m) %>%
    do(data.frame(loc = unique(.$loc_sum),
                  dens = approx(.$loc, .$dens, unique(.$loc_sum))[['y']])) %>%
    ungroup()
```

Create a vector of offsets with each x-axis group's coordinate
```{r}
offsets = unique(my_data[['x_group']]) %>% {setNames(0:(length(.) - 1), .)}

```

Offset the densities and summary statistics
Modify pdat and sums to add offset_dens columns, which are the density curve values offset by the x-axis group. Also, for the groups that are on the left side of the split violins, invert the densities

```{r}
pdat = pdat %>%
    mutate(offset_dens = offsets[.[['x_group']]] + ifelse(.[['m']] == splits[1], -dens, dens))

sums = sums %>%
    mutate(offset = offsets[.[['x_group']]],
           offset_dens = offset + ifelse(.[['m']] == splits[1], -dens, dens))
```

Plot
```{r}
ggplot(pdat, aes(offset_dens, loc, fill = m,
                 group = interaction(pdat[['x_group']], pdat[['m']]))) +
    geom_polygon() +
    geom_segment(data=sums, aes(x = offset, y = loc,
                                xend = offset_dens, yend = loc),
                 inherit.aes=FALSE) +
    scale_x_continuous(name = 'x_group',
                       breaks = unname(offsets),
                       labels = names(offsets)) +
    ylab('dv')
```


