---
title: "CV_analysis"
author: "Moaraj_Hasan"
date: "29 Januar 2017"
output:
  html_document: default
  pdf_document: default
---

Generate a Visual Basic Script that can convert xls and xlsx files into csv in local directory 
xls files are notoriously difficult to handle in R, csv conver              bvby~7En*UtG%y~7En*UtG%y~7En*UtG%sion allows low memory

```{r setup,}
#setwd("D:/Dropbox/Aging BXD Study/D _ Metabolomics/D _ Protocol Optimization/CV Calcs")

excel_script <- 
    'if WScript.Arguments.Count < 2 Then
    WScript.Echo "Please specify the source and the destination files. Usage: ExcelToCsv <xls/xlsx source file> <csv destination file>"
Wscript.Quit
End If

csv_format = 6

Set objFSO = CreateObject("Scripting.FileSystemObject")

src_file = objFSO.GetAbsolutePathName(Wscript.Arguments.Item(0))
dest_file = objFSO.GetAbsolutePathName(WScript.Arguments.Item(1))

Dim oExcel
Set oExcel = CreateObject("Excel.Application")

Dim oBook
Set oBook = oExcel.Workbooks.Open(src_file)

oBook.SaveAs dest_file, csv_format

oBook.Close False
oExcel.Quit'

script_file_name = "ExcelToCsv.vbs"
write(excel_script,file = script_file_name)
# The script above allows command line conversion of xlxs file to csv conversiton in command line
#The script syntax: 
#XlsToCsv.vbs [sourcexlsFile].xls [destinationcsvfile].csv

```

The following script takes thes first xls file and performs the conversion using the script
```{r, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
library(tools)
abs_path <- file_path_as_absolute(dir(pattern = "\\.xls")[1])
cmd_command <- paste(c(script_file_name, abs_path, 
                       paste(strsplit(abs_path,".xls"),".csv", sep = "")), 
                     sep = " ", collapse = " ")

system(command = cmd_command)
```

Install all the required dependcies
```{r, message=FALSE, warning=FALSE, eval=FALSE}
install.packages("dplyr")
install.packages("ggplot2")
install.packages("plyr")
install.packages("matrixStats")
install.packages("readr")
install.packages("tidyr")
install.packages("splitstackshape")
```

Initalize data handling dependencies
```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(plyr)
library(readr)
library(tidyr)
library(splitstackshape)
library(matrixStats)
library(tibble)
library(heplots)
library(sm)
library(vioplot)
```

Import Annotated Files, Tranposed, all commas, spaces and semi colons removed in notepad++. 
INSERT "index, extraction, mouse, diet, sex," to first row

```{r}
Data_Curated_Annotations_transpose <- read_csv("Data_Curated_Annotations_transpose.csv", 
    col_types = cols( `71.0137` = col_integer(), extraction = col_character(), 
        index = col_integer()))

metab_data <- Data_Curated_Annotations_transpose %>% dplyr::mutate_each_(., funs = funs(as.factor), vars = c("extraction", "diet", "sex", "mouse")) 


```

Add indexes for replicaites using the mod function on the sample index
```{r}
#mod<-function(x,m){
#    t1<-floor(x/m)
#    return(x-t1*m)
#}

#index_vector        <- c(1:nrow(metab_data))
#replicate_index     <- mod(metab_data$index,2)
#replicate_index     <- as.data.frame(as.character(rev((replicate_index + 1))))
#index_vector        <- cbind(index_vector, replicate_index)
#names(index_vector) <- c("index", "replicate")

metab_data <- merge(metab_data 
                    %>% mutate(replicate  = paste("rep_", rep(c(1,2), times = dim(metab_data)[1]/2), sep = "")) 
                    %>% select(index, replicate), metab_data, by = "index")

#zou need to have unqiue values in the bz mere
#can be done by selecting multiple columns
```


ANOVA fit
```{r, fig.height=4, fig.width=4}

Data_Annotations    <- read.csv(file = "Data_Curated_Annotations.csv",stringsAsFactors = FALSE)
primary_names       <- Data_Annotations$Primary.Name
meta_data           <- c("index","replicate","extraction","mouse","diet","sex")
primary_meta_names  <- c(meta_data, primary_names)

#names(metab_data)   <- primary_meta_names
#duplicated_colnames <- which(duplicated(primary_meta_names,fromLast = FALSE))
#metab_data<-lapply(duplicated_colnames, function(x) metab_data[-x])


duplicated_cols <- which(duplicated(primary_meta_names))
filtered_metab_data <- metab_data %>% select(-duplicated_cols)
filtered_primary_meta_names <- primary_meta_names[-duplicated_cols]
final_metab_data <- filtered_metab_data %>% setnames(filtered_primary_meta_names)

#Set up variables for the aov analysis

counts <- as.matrix(log(metab[7]))
#extraction  <- metab$extraction
#mouse   <- metab$mouse
#diet    <- metab$diet
#sex     <- metab$sex
#replicate <- metab$replicate
  
fit <- aov(formula = as.formula("counts ~ diet + replicate + extraction + sex"), data = filtered_metab_data)
fit2 <- glm(formula = as.formula("counts ~ sex + diet + extraction + replicate"), data = metab)

Tukey.fit <- TukeyHSD(fit, conf.level = 0.95)

#Run AOV using HEPlot package
metab.mod <- lm(as.matrix(metab[7]) ~ sex + diet, data=metab)
Anova(metab.mod, test.statistic="Roy")

#Get the Summary Table of the Fit
fit_summary <- summary(fit)
summary(fit2)

#Plot Graphs for the metabolite fits
plot(fit,which = 1:2)
plot(fit2, which = 1:6)

#Pair wise test to see if gender and sex cohorts make a significant difference
pairwise.t.test(as.matrix(metab[7]), g = sex ,p.adjust.method = "bonferroni")

#Try the AOV on a smaller subset of the data for just the NH24 extraction
NH24_data <- filter(final_metab_data,extraction == "NH24") %>% filter(sex == "F")
counts <- as.matrix(log(NH24_data[7:329]))
fit <- aov(formula = as.formula("counts ~ diet + replicate + mouse"), data = NH24_data)

fit_summary <- summary(fit)
fit_summary_table <- sapply(fit_summary[1:length(fit_summary)], function(x) cbind.data.frame(x))

NH24_f_value <- cbind.data.frame(fit_summary_table["F value",])
NH24_f_value <- y[-4,]
NH24_pr_f <- cbind.data.frame(fit_summary_table["Pr(>F)",])
NH24_pr_f <- z[-4,]

row.names(NH24_f_value) <- c("diet", "replicate", "mouse")
row.names(NH24_pr_f) <- c("diet", "replicate", "mouse")

NH24_pr_f_transpose <- t(NH24_pr_f)

alpha <- 0.05
n_tests <- nrow(NH24_pr_f_transpose)
bonf_correction <- alpha/n_tests


```

Generate Table to compare Chow and High Fat Diet metabolites
Script for extracting just cohort subsets for convienceie use anywhere in the analysis
```{r}
#Exctraction Cohorts
Hot_data  <- filter(final_metab_data,extraction == "Hot") %>% filter(sex == "F")
H1_data   <- filter(final_metab_data,extraction == "H1") %>% filter(sex == "F")
H24_data  <- filter(final_metab_data,extraction == "H24") %>% filter(sex == "F")
NH24_data <- filter(final_metab_data,extraction == "NH24") %>% filter(sex == "F")

#Diet Cohorts
HF_data <- filter(final_metab_data, diet == "HF") %>% filter(sex == "F")
CD_data <- filter(final_metab_data, diet == "CD") %>% filter(sex == "F")

#Replicate Cohorts
rep_1_data <- filter(final_metab_data, replicate == "rep_1") %>% filter(sex == "F")
rep_2_data <- filter(final_metab_data, replicate == "rep_2") %>% filter(sex == "F")


```

Violin Plots for the Metabolite Cohorts
```{r}
HF_mean <-as.numeric(lapply(HF_data[7:length(names(HF_data))], function(x) mean((x))))
CD_mean <-as.numeric(lapply(CD_data[7:length(names(CD_data))], function(x) mean((x))))

HF_sd <-as.numeric(lapply(HF_data[7:length(names(HF_data))], function(x) sd((x))))
CD_sd <-as.numeric(lapply(CD_data[7:length(names(CD_data))], function(x) sd((x))))

Hot_CV  <- as.numeric(lapply(Hot_data[7:ncol(Hot_data)], function(x) sd(x)/mean((x))*100))
H1_CV   <- as.numeric(lapply(H1_data[7:ncol(H1_data)], function(x) sd(x)/mean((x))*100))
H24_CV  <- as.numeric(lapply(H24_data[7:ncol(H24_data)], function(x) sd(x)/mean((x))*100))
NH24_CV <- as.numeric(lapply(NH24_data[7:ncol(NH24_data)], function(x) sd(x)/mean((x))*100))
Extraction_CV <- cbind(Hot_CV,H1_CV,H24_CV,NH24_CV)


CD_CV <-as.numeric (
        lapply     ( filter(CD_data, CD_data$extraction == "NH24")[7:length(names(rep_1_data))], 
        function(x) sd(x)/mean((x))*100 
                    ))

HF_CV <-as.numeric(lapply(rep_2_data[7:length(names(rep_2_data))], function(x) sd(x)/mean((x))*100))
Diet_CV <- cbind(CD_CV,HF_CV)

rep_1_CV <-as.numeric(lapply(rep_1_data[7:length(names(rep_1_data))], function(x) sd(x)/mean((x))*100))
rep_2_CV <-as.numeric(lapply(rep_2_data[7:length(names(rep_2_data))], function(x) sd(x)/mean((x))*100))
Rep_cv <- cbind(rep_1_CV,rep_2_CV) 


q <- ggplot(cbing(), aes(factor(variable), log(value)))
q + geom_violin() + geom_boxplot(width=.1) 
# violin plot with median points

vioplot2(Hot_data)
```




